# MyShell 设计文档

作者：龙静毅 3190101088

由于时间都花在写大作业上了，设计文档稍微简陋一点，只讲一讲最重要的部分。

## 整体逻辑

CLI 类负责前端的显示，即每一轮打印 prompt 以及作业信息

Parser 负责把输入转化为语法树

语法树的 Execute 函数负责执行相应的子树，调用跟节点的 Execute 即可执行整个命令

JobPool 负责记录作业的信息，当作业完成时通知 JobPool 修改信息。当调用 fg bg 指令的时候相应的从 JobPool 中获得 pid 等信息

SpecialVarPool 负责记录特殊变量如 $? $# $0 ~ $9

## 语法解析


整个解析过程分为两部分，首先使用一个分词器将命令按照空白字符划分为词语。然后再对词语进行解析。词语要么是符号，要么是命令（的一部分），我们把用符号分割开的命令合成一个命令。剩下的操作只需要像解析一个运算表达式一样进行，使用两个栈分别维护符号和命令就好了，遇到命令压入命令栈，遇到符号则把搜索当前符号栈顶的优先级大于当前符号的符号弹出，相应的把命令栈中的命令合并为一个命令，重新压入栈中。最后栈里剩下的就是我们期望的语法树跟节点了。

## 命令执行

基本上每一个 shell 都对应了一个 C 的标准库函数。所以在实现这些命令的具体执行的时候，只需要调用对应的标准库函数就好了。这部分没有太多技术含量，就不展开讲了。但其中 bg fg 和 jobs 指令涉及到作业控制，我们将在下面详细展开。

## 进程控制

进程控制分为三种情况：

1. 当前是 shell：
   1. 想要开启前台进程：新建进程，放入新的进程组，向作业池中添加作业，移交终端控制权，等待进程结束
   2. 想要开启后台进程：新建进程，放入新的进程组，向作业池中添加作业
2. 当前是除了 shell 之外的前台进程：
   1. 想要开启前台进程：新建进程，移交终端控制权，等待进程结束
   2. 想要开启后台进程：新建进程，执行当前进程的任务，最后再等待进程结束
3. 当前是后台进程：
   1. 想要开启后台进程：新建进程

解释如下：

1. 只有 shell 创建的进程才有可能被加入心的进程组，同时也必须添加到作业池中。这样保证了 shell 发起的作业均位于同一个进程组中，并且被作业池监视
2. 除了 shell 以外的前台进程之所以要等待子进程结束，并且这个行为是递归的，保证了 shell 亲自发起的进程组，也就是作业，只有当其所有进程均结束的时候才算结束，从而保证 shell 将其改为前台运行的时候不会有问题。

具体演示可以看实验报告部分

